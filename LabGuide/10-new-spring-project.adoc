= Spring Fundamentals, New Spring Project
:sectnums:


In this lab, you will setup a new Spring project in your IDE with help from Gradle.  These instructions are based on VSCode, however hints and tips are provided for IntelliJ and Eclipse.

Solution code is provided for you in a separate folder, so you can compare your work if needed.  For maximum benefit, try to complete the lab without looking at the solution.


== Open VS Code.

IMPORTANT: If you haven't installed the “Extension Pack for Java” (Microsoft) and “Gradle for Java” extensions yet, you can do so from the Extensions view (Ctrl+Shift+X or Cmd+Shift+X on macOS) by searching for name of the extension and clicking "Install".

==== Open VSCode.

==== Use Ctrl-Shift-P to open the `Command  Palette`.

==== Type "gradle".  Select _Gradle: Create a Gradle Java Project (Advanced)_  .

. You will be prompted to select a folder.  Select *C:\LabFiles\10-spring-intro*. Adjust the location if your lab files are located elsewhere.  Create this folder if it does not exist.

. For project type, select *application*.

. For build script DSL, select *Groovy*.

. For test framework, select *JUnit Jupiter*.

. For the name of your project, select *10-spring-intro*.

. For package name, type *com.example*
    * Give Gradle a moment to generate the project.  

. Once the project is generated, you will receive a message equivalent to _Gradle project [10-spring-intro] is created under: c:\LabFiles\10-spring-intro._  Click the "Open" button.
* If you see a message about enabling null analysis for the project, you can select either enable or disable.
* If you see a message about installing “Extension Pack for Java”, take the install option.
* If you see a message "Do you trust the authors of the files in this folder", check the checkbox and click the "trust" button.

== Run your application

* **Using VS Code:** Open app/src/main/java/com/example folder and find `App.java`. Right-click and select "Run Java". (Or, click the a “Run” option hovering over the main() method.)
* **Using IntelliJ:** Run the application by expanding the app/src/main/java folder, then the com.example package. Right-click on the `App.java` file. Select “Run ‘App.main()’”. 
* **Using Eclipse:** Run the application by expanding the app/src/main/java folder, then the com.example package. Right-click on the `App.java` file. Select Run As / Java Application.

. It may take a moment for the build to complete.
. We expect the application to start, produce some console output, then stop.

== Explore the project

The project generated by the Gradle extension is largely structure and configuration intended to provide a quick starting point for a typical Java application using the Gradle build process.

==== Take a moment to explore the structure and artifacts that are setup:

* The main folders in a Gradle/Maven based project are:
** `src/main/java`: This is where the main application code goes.
** `src/test/java`: This is where the test code goes.
** `src/main/resources`: This is where resources like properties files, etc. go.
** `src/test/resources`: This is where test resources go.

TIP: Each of these locations is considered "the root of the classpath".  This means that when you reference a file in your code, it is assumed to be relative to one of these locations.

. Open *build.gradle*. This is where we will define our dependencies. It is the rough equivalent of Python's requirements.txt, JavaScript's package.json, C#'s project.csproj, etc.  Notice the following:
** The dependencies section is empty, other than a reference to JUnit for testing.  We will place Spring dependencies here in a bit.
** The repositories section describes where dependencies can be
downloaded from. For security purposes, many companies like to override
this to use their own privately hosted repositories.
. Open *App.java* in src/main/java/com/webage. Notice:
** A single `public static void main(String[] args)` method. In Java,
such methods are invoked from the command line. This will serve as the
main entry point to the application.
. Open *AppTest.java* in src/test/java/com/webage.
** This is a JUnit test class. Tools like Gradle / Maven understand
that classes under src/test/java are test classes to be used when we ask
to test our code.
. Run the test:
* *VS Code:* Right-click on the file in the folder structure and select "Run Java" or "Run Tests".  (Or, notice the green triangle in the editor’s “gutter”. Click on this to run either an individual test method or all tests in the class.)
* *Eclipse:* Right-click on the class. Select Run As / Junit Test.
* *IntelliJ:* Right-click on the class. Select Run ‘ApplicationTests’

==== Observe the test results.  The test should pass.

== Add Spring Dependencies
The Spring framework has many modules. We will add the essential Spring dependencies to the *build.gradle* file.

TIP: Later when using Spring Boot, we will only need to add a single dependency.  For now we will do things the long way.

==== Open *build.gradle*.  Change the dependencies section so it matches the following:

[source,gradle]
----


dependencies {
    implementation "org.springframework:spring-core:6.1.8"  
    implementation 'org.springframework:spring-context:6.1.8'  
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.1'
    testImplementation "org.assertj:assertj-core:3.11.1"    
}

----

These dependencies are the absolute minimum needed to use Spring and run basic JUnit tests.  AssertJ is commonly used in JUnit test cases.  We will add more dependencies later.

==== Save your work.
* You may see a message _A build file was modified. Do you want to synchronize the Java classpath/configuration?_  We recommend choosing *Always*.
* Your IDE should automatically detect the changes and download the new dependencies.  If not, you may need to restart it.



== Create a simple bean and configuration file.

==== Within `src/main/java/com.example`, create new Java class named *Greeting.java*.

NOTE: In VSCode, be sure to request a "New Java File..." rather than simply a "New File...".  The former will contain a correctly defined class definition.

==== Create a method called *getGreeting()* which returns a simple String message:

```

    public String getGreeting() {
        return "Hello World!";
    }  

```

==== Save your work.

==== Within `src/main/java/com/example`, create new Java file named *Config.java*.

==== Add Spring's `@Configuration` annotation to the class definition:
```

@Configuration   
public class Config {

```
* This designates this class as a configuration class containing Spring bean definitions.

TIP:    In most IDEs while you type the name of a class, the IDE will often offer to complete the text for you. This "code completion" or "intellisense" not only avoids typos, but automatically imports the correct type for you.  Be aware that sometimes there are multiple types with the same name, so you may need to select the correct one.




==== Add a method annotated with `@Bean` that defines a Spring bean of type `Greeting` having the name `greetingBean`:

```

    @Bean
    public Greeting greetingBean() {
        return new Greeting();
    }

```

* The name of the method becomes the ID / name of the bean.
* The return value of the method is the TYPE of the bean.
* The method body contains instantiation instructions.


==== Organize your imports and save your work.
* Java types must be imported to be referenced in code. IDEs can usually do this for you with some keystrokes:
* **VS Code**: Alt-Shift-O.
* **IntelliJ**: Ctrl-Alt-O.
* **Eclipse**: Ctrl-Shift-O.

== Modify App.java

==== Open *App.java* in src/main/java/com/example.

==== Replace the `main()` method with the following:

```
    public static void main(String[] args) {
        ApplicationContext spring = 
            new AnnotationConfigApplicationContext(Config.class);

        Greeting greetingBean = spring.getBean(Greeting.class);        
        System.out.println(greetingBean.getGreeting());
    }

```
.. `AnnotationConfigApplicationContext` instantiates a Spring `ApplicationContext` using definitions found in `Config.class`.
.. `getBean()` retrieves a bean from the context by type.
.. `System.out.println()` prints the greeting message to the console.

==== Organize your imports and save your work.

==== Run the application.  It should start, display a message, then stop.

== Create an Integration Test.
Anything that we code, we should test.  We will revise the *AppTest.java* file to test that our Spring configuration correctly builds the beans as directed.

==== Open `src/test/java/com.example.AppTest.java`.

==== Remove the existing contents of the class definition (everything between the { and }).
* The result should look like this:
----
class AppTest {

}
----

==== Define a static variable of type Greeeting:

```
    private static Greeting greetingBean;
```
* This will hold a reference to the bean we are testing.

==== Add a setup method annotated with @BeforeAll.  Within, write the following code (use the App.java code as a guide):
. Create an ApplicationContext using the Config class.
. Retrieve the greetingBean from the context and assign it to the greetingBean *static variable*.

----
    @BeforeAll
    public static void setup() {
        ApplicationContext spring = 
            new AnnotationConfigApplicationContext(Config.class);
        greetingBean = spring.getBean(Greeting.class);        
    }
----


==== Add a test method annotated with @Test.  Provide the following implementation:

```
    @Test 
    void testGreeting() {

        Assertions.assertThat(greetingBean.getGreeting()).isEqualTo("Hello World!");
    
    }
```
* This method uses AssertJ to test that the greeting message is as expected.

==== Organize your imports.  
* Be sure to use the AssertJ import for Assertions rather than the JUnit one by the same name, or your code will not compile.  The resulting import should say `import org.assertj.core.api.Assertions;`.

==== Save your work.  Run the test, it should pass.

== Review

In this lab we learned:

* How to create a new Spring project using Gradle.
* How to add Spring dependencies to the build file.
* How to create a `@Configuration` class for our bean definitions.
* How to create a simple `@Bean` definition.
* How to instantiate the Spring context and retrieve a bean.
* How to create a simple integration test.

Spring is a powerful framework that can do much more than this.  In the next lab, we will explore a more complex example.













